{
	// 数位DP
	"digit dp":{
		"prefix": "digit_dp_class",
		"body":[
			"'''",
			"mask: 是否选过;",
			"isLimit: 表示当前是否受到了 n 的约束(注意要构造的数字不能超过 n);",
			"isNum: 表示 i 前面的数位是否填了数字;",
			"x: 当前状态，也可表示其他约束条件，需要自行改造。",
			"'''",
			"class DigitDP:",
			"    def __init__(self):",
			"        self.is_mod = True",
			"        self.MOD = 10 ** 9 + 7",
			"        self.repeat = False # 是否允许重复数字",
			"        self.leading_zero = False # 是否允许前导0",
			"        self.iter_cond = lambda x, y: True # 递推约束条件",
			"        self.iter_op = lambda x, y: x # 递推方式",
			"        self.return_cond = lambda x: x > 0 # 计数约束条件",
			"",
			"    def get_count(self, s):",
			"        @cache",
			"        def f(i: int, mask: int, is_limit: bool, is_num: bool, x: int) -> int:",
			"            if i == len(s): return int(is_num and self.return_cond(x))",
			"            res = 0",
			"            if not is_num: res = f(i + 1, mask, False, False, x)",
			"            low = 0 if is_num else 1",
			"            up = int(s[i]) if is_limit else 9",
			"            for d in range(low, up + 1):",
			"                if self.repeat:",
			"                    if self.iter_cond(d, x):",
			"                        res += f(i + 1, mask, is_limit and d == up, True, self.iter_op(d, x))",
			"                else:",
			"                    if self.iter_cond(d, x) and (mask >> d & 1) == 0:",
			"                        res += f(i + 1, mask | (1 << d), is_limit and d == up, True, self.iter_op(d, x))",
			"                if self.is_mod: res %= self.MOD",
			"            return res",
			"        return f(0, 0, True, self.leading_zero, 0)",
			"",
			"digit_dp = DigitDP()",
			"cnt = digit_dp.get_count(s) # s: str, 范围: (0, int(s)]",			
		]
	},
	"matrix quick power":{
		"prefix": "matrix_pow_dp_class",
		"body":[
			"class MatrixPow:",
			"    def __init__(self, matrix, is_mod=False):",
			"        self.matrix = matrix",
			"        self.n = len(matrix)",
			"        self.MOD = 10 ** 9 + 7",
			"        self.is_mod = is_mod",
			"",
			"    # 矩阵乘法",
			"    def multiply(self, a: list[list[int]], b: list[list[int]]) -> list[list[int]]:",
			"        c = [[0 for _ in range(self.n)] for _ in range(self.n)]",
			"        for i in range(self.n):",
			"            for j in range(self.n):",
			"                for k in range(self.n):",
			"                    c[i][j] += a[i][k] * b[k][j] ",
			"                    if self.is_mod: c[i][j] %= self.MOD",
			"        return c",
			"",
			"    # 矩阵快速幂",
			"    def pow(self, k: int) -> list[list[int]]:",
			"        res = [[0 for _ in range(self.n)] for _ in range(self.n)]",
			"        a = self.matrix",
			"        for i in range(self.n): res[i][i] = 1",
			"        while k:",
			"            if k % 2:",
			"                res = self.multiply(res, a)",
			"            a = self.multiply(a, a)",
			"            k //= 2",
			"        return res",
			"",
			"mat = [",
			"    [1, 1],",
			"    [1, 0]",
			"]",
			"matrix_pow = MatrixPow(mat)",
			"mat = matrix_pow.pow(k=k) # k次幂",
		]
	},
	"rerooting dp":{
		"prefix": "rerooting_dp_class",
		"body":[
			"class RerootingDP:",
			"    def __init__(self, n:int, edges=[], undirected=True):",
			"        self.n = n",
			"        self.g = [[] for _ in range(n)]",
			"        self.undirected = undirected",
			"        for x, y, w in edges: self.add_edge(x, y, w)",
			"    ",
			"    def add_edge(self, x, y, w):",
			"        self.g[x].append((y, w))",
			"        self.g[y].append((x, w * 2 * int(self.undirected) - 1))",
			"",
			"    def get_result(self) -> list[int]:",
			"        result, size = [0] * self.n,  [1] * self.n",
			"        # ** 专心计算0号节点的结果 **",
			"        def dfs(x: int, fa: int, depth: int) -> None:",
			"            result[0] += depth  # depth 为 0 到 x 的距离",
			"            for y, w in self.g[x]:  # 遍历 x 的邻居 y",
			"                if y != fa:  # 避免访问父节点",
			"                    dfs(y, x, depth + w)  # x 是 y 的父节点",
			"                    size[x] += size[y]  # 累加 x 的儿子 y 的子树大小",
			"        dfs(0, -1, 0)  # 0 没有父节点",
			"        # ** 只需要考虑相邻节点 x 和 y 的相对关系即可 **",
			"        def reroot(x: int, fa: int) -> None:",
			"            for y, w in self.g[x]:  # 遍历 x 的邻居 y",
			"                if y != fa:  # 避免访问父节点",
			"                    result[y] = result[x] + self.n - 2 * size[y] ",
			"                    reroot(y, x)  # x 是 y 的父节点",
			"        reroot(0, -1)  # 0 没有父节点",
			"        return result",
			"",
			"rerooting_dp = RerootingDP(n=n, edges=edges, undirected=True)",
			"res_lst = rerooting_dp.get_result()",			
		]
	},
	"tree doubling":{
		"prefix": "tree_doubling_class",
		"body":[
			"class TreeDoubling:",
			"    '''",
			"    parents: 父节点关系的数组，parents[i] 是 i 的父节点",
			"    k: 最大查询范围，可以很大（10**10）,反正会指数折叠",
			"    '''",
			"    def __init__(self, parents, k):",
			"        m = k.bit_length()",
			"        pa = {}",
			"        for x, p in parents.items():",
			"            y = 0 if p is None else p",
			"            pa[x] = [(p, y)] + [(None, 0)] * m",
			"        pa[None] = [(None, 0)] * m",
			"        for i in range(m):",
			"            for x in parents:",
			"                p, s = pa[x][i]",
			"                pp, ps = pa[p][i]",
			"                pa[x][i+1] = (pp, ps + s)",
			"        self.pa = pa",
			"",
			"    def get_Kth_ancestor(self, node, k):",
			"        s0 = node",
			"        for i in range(k.bit_length()):",
			"            if (k >> i) & 1:",
			"                node, s = self.pa[node][i]",
			"                if node is None: return None, 0",
			"                s0 += s # 与 ps + s 的累加关系对应修改",
			"        return node, s0",
			"parents_dct = {i:x for i, x in enumerate(parent)}",
			"# parents_dct[-1] = None",
			"self.tree_doubling = TreeDoubling(parents=parents_dct, k=10**10)",
			"# node: 要查询的节点, k: 与节点x的距离, kth_node: 距离为k的祖先节点, val: 倍增累加和",
			"kth_node, val = self.tree_doubling.get_Kth_ancestor(node=node, k=k)",
		]
	},
}