{
    "Union-find":{
		"prefix": "uf_class",
		"body":[
			"class IdentityDefaultDict(defaultdict):",
			"    '''",
			"    该类用于处理并查集初始化的恒等映射",
			"    '''",
			"    def __missing__(self, key):",
			"        return key",
			"",
			"class UnionFind:",
			"    def __init__(self, n=None):",
			"        self.parent = IdentityDefaultDict()",
			"        if n: self.parent = list(range(n))",
			"    def find(self, x):",
			"        if self.parent[x] != x: self.parent[x] = self.find(self.parent[x])",
			"        return self.parent[x]",
			"    def merge(self, x, y):",
			"        x, y = self.find(x), self.find(y)",
			"        if x != y: self.parent[x] = y",
			"    def get_group_count(self):",
			"        return len(set(self.find(x) for x in self.parent))"
			"uf = UnionFind(n=n) # 也可不填写点的个数"
		],
	},
	"Dijkstra":{
		"prefix": "dijkstra_class",
		"body":[
			"class Dijkstra:",
			"    def __init__(self, edges=[], undirected=True):",
			"        self.g = defaultdict(list)",
			"        self.undirected = undirected",
			"        for x, y, w in edges: self.add_edge(x, y, w)",
			"    def get_min_dist(self, src=0):",
			"        dist = defaultdict(lambda:inf)",
			"        dist[src] = 0",
			"        sl = [(dist[src], src)]",
			"        while sl:",
			"            d, x = heappop(sl)",
			"            for y, cost in self.g[x]:",
			"                if dist[x] + cost < dist[y]:",
			"                    dist[y] = dist[x] + cost",
			"                    heappush(sl, (dist[y], y))",
			"        return dist",
			"    def add_edge(self, x, y, w):",
			"        self.g[x].append((y, w))",
			"        if self.undirected: self.g[y].append((x, w))",
			"        ",
			"dijkstra = Dijkstra(edges=edges, undirected=True) # 无向图",
			"# dijkstra.add_edge(x, y, w)",
			"src, dst = 0, 1",
			"min_dist = dijkstra.get_min_dist(src=src)[dst]",			
		],
	},
	"Dinic-MinCost":{
		"prefix": "dinic_min_cost_max_flow_class",
		"body":[
			"class Node:",
			"    def __init__(self):",
			"        self.val, self.v, self.next, self.w = 0, 0, 0, 0",
			"",
			"class Dinic:",
			"    def __init__(self, src, dst, n=5010):",
			"        self.nodes = [Node() for _ in range(2)]",
			"        self.top = 1",
			"        self.s, self.t = src, dst",
			"        self.N = n",
			"        self.head, self.vis, self.dist = [0] * self.N, [0] * self.N, [inf] * self.N",
			"        self.cost, self.maxflow = 0, 0",
			"    ",
			"    def _add_edge(self, u, v, val, w):",
			"        self.nodes.append(Node())",
			"        self.top += 1",
			"        self.nodes[self.top].v = v",
			"        self.nodes[self.top].w = w",
			"        self.nodes[self.top].val = val",
			"        self.nodes[self.top].next = self.head[u]",
			"        self.head[u] = self.top",
			"    ",
			"    def add_edge(self, u, v, val, w=0):",
			"        self._add_edge(u , v, val, w)",
			"        self._add_edge(v, u, 0, -w)",
			"    ",
			"    def spfa(self)->bool:",
			"        self.vis, self.dist = [0] * self.N, [inf] * self.N",
			"        self.dist[self.s], self.vis[self.s] = 0, 1",
			"        dq = deque([self.s])",
			"        ",
			"        while dq:",
			"            u = dq.popleft()",
			"            self.vis[u] = 0",
			"            i = self.head[u]",
			"            while i:",
			"                d = self.nodes[i].v",
			"                if self.dist[u] + self.nodes[i].w < self.dist[d] and self.nodes[i].val:",
			"                    self.dist[d] = self.dist[u] + self.nodes[i].w",
			"                    if self.vis[d] == 0: ",
			"                        dq.append(d)",
			"                        self.vis[d] = 1",
			"                i = self.nodes[i].next",
			"        return self.dist[self.t] != inf",
			"    ",
			"    def dfs(self, u, flow)->int:",
			"        if u == self.t:",
			"            self.vis[self.t] = 1",
			"            self.maxflow += flow",
			"            return flow",
			"        used = 0",
			"        self.vis[u] = 1",
			"        i = self.head[u]",
			"        while i:",
			"            d = self.nodes[i].v",
			"            if (self.vis[d] == 0 or d == self.t) and self.nodes[i].val != 0 and self.dist[d] == self.dist[u] + self.nodes[i].w:",
			"                minflow = self.dfs(d, min(flow-used, self.nodes[i].val))",
			"                if minflow != 0:",
			"                    self.cost += self.nodes[i].w * minflow",
			"                    self.nodes[i].val -= minflow",
			"                    self.nodes[i^1].val += minflow",
			"                    used += minflow",
			"                if used == flow: break",
			"            i = self.nodes[i].next",
			"        return used",
			"",
			"    def get_max_flow_min_cost(self):",
			"        while self.spfa():",
			"            self.vis[self.t] = 1",
			"            while self.vis[self.t]:",
			"                self.vis = [0] * self.N",
			"                self.dfs(self.s, inf)",
			"        return self.maxflow, self.cost",
			"",
			"src, dst = n+1, n+2",
			"dinic = Dinic(src=src, dst=dst, n=n+3)",
			"",
			"for x, y, vol, costin edges:",
			"    dinic.add_edge(x, y, vol, cost) # 有向边: x->起点，y->终点，vol->流量, cost->费用",
			"maxflow, mincost = dinic.get_max_flow_min_cost()",					
		],
	},
	"Hierholzer":{
		"prefix": "hierholzer_class",
		"body":[
			"class Hierholzer:",
			"    def __init__(self, edges=[], undirected=True):",
			"        self.g = defaultdict(list)",
			"        self.undirected = undirected",
			"        for x, y in edges: self.add_edge(x, y)",
			"",
			"    def get_path(self, src=0):",
			"        g = deepcopy(self.g)",
			"        path = []",
			"        def dfs(x):",
			"            while g[x]: dfs(heappop(g[x]))",
			"            path.append(x)",
			"        dfs(src)",
			"        return path[::-1]",
			"    ",
			"    def add_edge(self, x, y):",
			"        heappush(self.g[x], y)",
			"        if self.undirected: heappush(self.g[y], x)",
			"",
			"hierholzer = Hierholzer(edges=edges, undirected=True)",
			"# hierholzer.add_edge(x, y)",
			"path = hierholzer.get_path(src=0)",
		],
	},
	"Tarjan":{
		"prefix": "tarjan_class",
		"body":[
			"class Tarjan:",
			"    def __init__(self, edges=[], undirected=True):",
			"        root = edges[0][0]",
			"        self.undirected = undirected",
			"        self.g, children = defaultdict(list), defaultdict(list)",
			"        for x, y in edges: self.add_edge(x, y)",
			"        dfn, low = defaultdict(lambda: inf), defaultdict(lambda: inf)",
			"        edges2, ts = [], 0  # edges2: 除去子节点到父节点边的集合",
			"",
			"        def f(x, p):",
			"            nonlocal ts",
			"            low[x] = dfn[x] = ts = ts + 1",
			"            for y in self.g[x]:",
			"                if y == p: continue",
			"                edges2.append([x, y])",
			"                if dfn[y] == inf:",
			"                    f(y, x)",
			"                    children[x].append(y)",
			"                low[x] = min(low[x], low[y])",
			"        f(root, -1)",
			"        bridges = sorted([x, y] for x, y in edges2 if low[y] > dfn[x])",
			"        artis = []  # 割点",
			"        for x, ys in children.items():",
			"            if x == root and len(children[x]) >= 2: artis.append(x)",
			"            if x != root:",
			"                for y in ys:",
			"                    if low[y] >= dfn[x]:",
			"                        artis.append(x)",
			"                        break",
			"        self.bridges, self.artis = bridges, artis",
			"",
			"    def get_bridges_and_artis(self):",
			"        return self.bridges, self.artis",
			"    ",
			"    def add_edge(self, x, y):",
			"        self.g[x].append(y)",
			"        if self.undirected: self.g[y].append(x)",
			"",
			"tarjan = Tarjan(edges=edges, undirected=True)",
			"# tarjan.add_edge(x, y)",
			"bridges, artis = tarjan.get_bridges_and_artis() # 桥与割点",			
		],
	},
}